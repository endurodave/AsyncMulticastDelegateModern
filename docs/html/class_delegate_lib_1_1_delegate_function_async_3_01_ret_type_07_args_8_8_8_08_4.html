<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Delegates: DelegateLib::DelegateFunctionAsync&lt; RetType(Args...)&gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Delegates
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_delegate_lib_1_1_delegate_function_async_3_01_ret_type_07_args_8_8_8_08_4.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_delegate_lib_1_1_delegate_function_async_3_01_ret_type_07_args_8_8_8_08_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DelegateLib::DelegateFunctionAsync&lt; RetType(Args...)&gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code><a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateFunctionAsync</a>&lt;&gt;</code> class asynchronously invokes a <code>std::function</code> target function.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_delegate_async_8h_source.html">DelegateAsync.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DelegateLib::DelegateFunctionAsync&lt; RetType(Args...)&gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_delegate_lib_1_1_delegate_function_async_3_01_ret_type_07_args_8_8_8_08_4.png" usemap="#DelegateLib::DelegateFunctionAsync_3C_20RetType_28Args..._29_3E_map" alt=""/>
  <map id="DelegateLib::DelegateFunctionAsync_3C_20RetType_28Args..._29_3E_map" name="DelegateLib::DelegateFunctionAsync_3C_20RetType_28Args..._29_3E_map">
<area href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html" title="DelegateFunction&lt;&gt; class synchronously invokes a std::function target function." alt="DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;" shape="rect" coords="0,112,332,136"/>
<area href="class_delegate_lib_1_1_i_delegate_invoker.html" title="Abstract base class to support asynchronous delegate function invoke on destination thread of control..." alt="DelegateLib::IDelegateInvoker" shape="rect" coords="342,112,674,136"/>
<area href="class_delegate_lib_1_1_delegate_3_01_ret_type_07_args_8_8_8_08_4.html" title="Template base class for all delegates." alt="DelegateLib::Delegate&lt; RetType(Args...)&gt;" shape="rect" coords="0,56,332,80"/>
<area href="class_delegate_lib_1_1_delegate_base.html" title="Non-template base class for all delegates." alt="DelegateLib::DelegateBase" shape="rect" coords="0,0,332,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4002625654c02248b5b37266bf63ef66" id="r_a4002625654c02248b5b37266bf63ef66"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4002625654c02248b5b37266bf63ef66">FunctionType</a> = std::function&lt;RetType(Args...)&gt;</td></tr>
<tr class="separator:a4002625654c02248b5b37266bf63ef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e95505c52ba0355839a32e2cacc3480" id="r_a4e95505c52ba0355839a32e2cacc3480"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> = <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateFunctionAsync</a>&lt;RetType(Args...)&gt;</td></tr>
<tr class="separator:a4e95505c52ba0355839a32e2cacc3480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a303bc469c86c9f50979caae34f2d51" id="r_a2a303bc469c86c9f50979caae34f2d51"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a303bc469c86c9f50979caae34f2d51">BaseType</a> = <a class="el" href="class_delegate_lib_1_1_delegate_function.html">DelegateFunction</a>&lt;RetType(Args...)&gt;</td></tr>
<tr class="separator:a2a303bc469c86c9f50979caae34f2d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html">DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;</a></td></tr>
<tr class="memitem:ab301553daa1552051356610973a9a284 inherit pub_types_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_ab301553daa1552051356610973a9a284"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#ab301553daa1552051356610973a9a284">FunctionType</a> = std::function&lt;RetType(Args...)&gt;</td></tr>
<tr class="separator:ab301553daa1552051356610973a9a284 inherit pub_types_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a948c89c10c03e795303f752c828c7 inherit pub_types_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a50a948c89c10c03e795303f752c828c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> = <a class="el" href="class_delegate_lib_1_1_delegate_function.html">DelegateFunction</a>&lt;RetType(Args...)&gt;</td></tr>
<tr class="separator:a50a948c89c10c03e795303f752c828c7 inherit pub_types_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46501e1a3392ed1d13e3f3cba8eb2df0" id="r_a46501e1a3392ed1d13e3f3cba8eb2df0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46501e1a3392ed1d13e3f3cba8eb2df0">DelegateFunctionAsync</a> (<a class="el" href="#a4002625654c02248b5b37266bf63ef66">FunctionType</a> func, <a class="el" href="class_delegate_lib_1_1_delegate_thread.html">DelegateThread</a> &amp;thread)</td></tr>
<tr class="memdesc:a46501e1a3392ed1d13e3f3cba8eb2df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to create a class instance.  <br /></td></tr>
<tr class="separator:a46501e1a3392ed1d13e3f3cba8eb2df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb983602c9e3fcecc54907f13b748ce" id="r_a2fb983602c9e3fcecc54907f13b748ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fb983602c9e3fcecc54907f13b748ce">DelegateFunctionAsync</a> (const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2fb983602c9e3fcecc54907f13b748ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that creates a copy of the given instance.  <br /></td></tr>
<tr class="separator:a2fb983602c9e3fcecc54907f13b748ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeef2c1b2f887384a21024779b298445" id="r_adeef2c1b2f887384a21024779b298445"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeef2c1b2f887384a21024779b298445">DelegateFunctionAsync</a> (<a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:adeef2c1b2f887384a21024779b298445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that transfers ownership of resources.  <br /></td></tr>
<tr class="separator:adeef2c1b2f887384a21024779b298445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cd46ce7ba0c9cb5ed9996dd1bddad6" id="r_a04cd46ce7ba0c9cb5ed9996dd1bddad6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04cd46ce7ba0c9cb5ed9996dd1bddad6">DelegateFunctionAsync</a> ()=default</td></tr>
<tr class="separator:a04cd46ce7ba0c9cb5ed9996dd1bddad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56758d6e931fbff1cfc3ea97151fd6b5" id="r_a56758d6e931fbff1cfc3ea97151fd6b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56758d6e931fbff1cfc3ea97151fd6b5">Bind</a> (<a class="el" href="#a4002625654c02248b5b37266bf63ef66">FunctionType</a> func, <a class="el" href="class_delegate_lib_1_1_delegate_thread.html">DelegateThread</a> &amp;thread)</td></tr>
<tr class="memdesc:a56758d6e931fbff1cfc3ea97151fd6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a <code>std::function</code> to the delegate.  <br /></td></tr>
<tr class="separator:a56758d6e931fbff1cfc3ea97151fd6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51e00822c91e01e7041be385ac38c76" id="r_ae51e00822c91e01e7041be385ac38c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae51e00822c91e01e7041be385ac38c76">Assign</a> (const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;rhs)</td></tr>
<tr class="memdesc:ae51e00822c91e01e7041be385ac38c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the state of one object to another.  <br /></td></tr>
<tr class="separator:ae51e00822c91e01e7041be385ac38c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12be5d3ae814bea5de0df73d2807bedd" id="r_a12be5d3ae814bea5de0df73d2807bedd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12be5d3ae814bea5de0df73d2807bedd">Clone</a> () const override</td></tr>
<tr class="memdesc:a12be5d3ae814bea5de0df73d2807bedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the current object.  <br /></td></tr>
<tr class="separator:a12be5d3ae814bea5de0df73d2807bedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203dd774ded780851f79cac05c4c719b" id="r_a203dd774ded780851f79cac05c4c719b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a203dd774ded780851f79cac05c4c719b">operator=</a> (const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;rhs)</td></tr>
<tr class="memdesc:a203dd774ded780851f79cac05c4c719b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that assigns the state of one object to another.  <br /></td></tr>
<tr class="separator:a203dd774ded780851f79cac05c4c719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac677a19f9c6ed6f0d5be06e8b1733d37" id="r_ac677a19f9c6ed6f0d5be06e8b1733d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac677a19f9c6ed6f0d5be06e8b1733d37">operator=</a> (<a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac677a19f9c6ed6f0d5be06e8b1733d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that transfers ownership of resources.  <br /></td></tr>
<tr class="separator:ac677a19f9c6ed6f0d5be06e8b1733d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeae73b60fd98848556101742538946" id="r_aaaeae73b60fd98848556101742538946"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaeae73b60fd98848556101742538946">operator=</a> (std::nullptr_t) noexcept override</td></tr>
<tr class="memdesc:aaaeae73b60fd98848556101742538946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the target function.  <br /></td></tr>
<tr class="separator:aaaeae73b60fd98848556101742538946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26e80dc355d468498afff49fe33762e" id="r_aa26e80dc355d468498afff49fe33762e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa26e80dc355d468498afff49fe33762e">Equal</a> (const <a class="el" href="class_delegate_lib_1_1_delegate_base.html">DelegateBase</a> &amp;rhs) const override</td></tr>
<tr class="memdesc:aa26e80dc355d468498afff49fe33762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two delegate objects for equality.  <br /></td></tr>
<tr class="separator:aa26e80dc355d468498afff49fe33762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f41a0cfc08394b14f178e7b7b667224" id="r_a8f41a0cfc08394b14f178e7b7b667224"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f41a0cfc08394b14f178e7b7b667224">operator==</a> (const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;rhs) const noexcept</td></tr>
<tr class="separator:a8f41a0cfc08394b14f178e7b7b667224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa088fc34ca30b023b0469ab60bf13e92" id="r_aa088fc34ca30b023b0469ab60bf13e92"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa088fc34ca30b023b0469ab60bf13e92">operator==</a> (std::nullptr_t) const noexcept override</td></tr>
<tr class="separator:aa088fc34ca30b023b0469ab60bf13e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ed368f2c82a7a70f658d386613a0a1" id="r_af8ed368f2c82a7a70f658d386613a0a1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8ed368f2c82a7a70f658d386613a0a1">operator!=</a> (std::nullptr_t) const noexcept override</td></tr>
<tr class="separator:af8ed368f2c82a7a70f658d386613a0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6153da03f3d607b1e18deb391c04a4" id="r_a1e6153da03f3d607b1e18deb391c04a4"><td class="memItemLeft" align="right" valign="top">virtual RetType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e6153da03f3d607b1e18deb391c04a4">operator()</a> (Args... args) override</td></tr>
<tr class="memdesc:a1e6153da03f3d607b1e18deb391c04a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the bound delegate function asynchronously. Called by the source thread.  <br /></td></tr>
<tr class="separator:a1e6153da03f3d607b1e18deb391c04a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0e0c2591b0b02feec73b501325fcb6" id="r_a5c0e0c2591b0b02feec73b501325fcb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c0e0c2591b0b02feec73b501325fcb6">AsyncInvoke</a> (Args... args)</td></tr>
<tr class="memdesc:a5c0e0c2591b0b02feec73b501325fcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke delegate function asynchronously. Do not wait for return value. Called by the source thread. Always safe to call.  <br /></td></tr>
<tr class="separator:a5c0e0c2591b0b02feec73b501325fcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b54529a25ce5ee655ce18baa8527f3a" id="r_a2b54529a25ce5ee655ce18baa8527f3a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b54529a25ce5ee655ce18baa8527f3a">Invoke</a> (std::shared_ptr&lt; <a class="el" href="class_delegate_lib_1_1_delegate_msg.html">DelegateMsg</a> &gt; msg) override</td></tr>
<tr class="memdesc:a2b54529a25ce5ee655ce18baa8527f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the delegate function on the destination thread. Called by the destintation thread.  <br /></td></tr>
<tr class="separator:a2b54529a25ce5ee655ce18baa8527f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd821f85fe65d031a307cf2a8f766d6" id="r_a1bd821f85fe65d031a307cf2a8f766d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_delegate_lib_1_1_delegate_thread.html">DelegateThread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bd821f85fe65d031a307cf2a8f766d6">GetThread</a> () noexcept</td></tr>
<tr class="memdesc:a1bd821f85fe65d031a307cf2a8f766d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the destination thread that the target function is invoked on.  <br /></td></tr>
<tr class="separator:a1bd821f85fe65d031a307cf2a8f766d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html">DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;</a></td></tr>
<tr class="memitem:a4f5654f2336389d28212ec1d38c7f56d inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a4f5654f2336389d28212ec1d38c7f56d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a4f5654f2336389d28212ec1d38c7f56d">DelegateFunction</a> (<a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#ab301553daa1552051356610973a9a284">FunctionType</a> func)</td></tr>
<tr class="memdesc:a4f5654f2336389d28212ec1d38c7f56d inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to create a class instance.  <br /></td></tr>
<tr class="separator:a4f5654f2336389d28212ec1d38c7f56d inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a92291f285ef7ef68cdc61b2201c5b5 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a1a92291f285ef7ef68cdc61b2201c5b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a1a92291f285ef7ef68cdc61b2201c5b5">DelegateFunction</a> (const <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1a92291f285ef7ef68cdc61b2201c5b5 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that creates a copy of the given instance.  <br /></td></tr>
<tr class="separator:a1a92291f285ef7ef68cdc61b2201c5b5 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75aab7b61893e8c842451491f72be23 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_ae75aab7b61893e8c842451491f72be23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#ae75aab7b61893e8c842451491f72be23">DelegateFunction</a> (<a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae75aab7b61893e8c842451491f72be23 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor that transfers ownership of resources.  <br /></td></tr>
<tr class="separator:ae75aab7b61893e8c842451491f72be23 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7080af7cb53567524dcfa05eb092c427 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a7080af7cb53567524dcfa05eb092c427"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a7080af7cb53567524dcfa05eb092c427">DelegateFunction</a> ()=default</td></tr>
<tr class="memdesc:a7080af7cb53567524dcfa05eb092c427 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor creates an empty delegate.  <br /></td></tr>
<tr class="separator:a7080af7cb53567524dcfa05eb092c427 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118c91ba17e9b57240a1cbf9072a6574 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a118c91ba17e9b57240a1cbf9072a6574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a118c91ba17e9b57240a1cbf9072a6574">~DelegateFunction</a> ()</td></tr>
<tr class="memdesc:a118c91ba17e9b57240a1cbf9072a6574 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor ensures empty when destroyed.  <br /></td></tr>
<tr class="separator:a118c91ba17e9b57240a1cbf9072a6574 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08b89338a2ebf38fe31af77c5f9b400 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_ae08b89338a2ebf38fe31af77c5f9b400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#ae08b89338a2ebf38fe31af77c5f9b400">Bind</a> (<a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#ab301553daa1552051356610973a9a284">FunctionType</a> func)</td></tr>
<tr class="memdesc:ae08b89338a2ebf38fe31af77c5f9b400 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a member function to the delegate.  <br /></td></tr>
<tr class="separator:ae08b89338a2ebf38fe31af77c5f9b400 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fded7c503030e142d45bfbeed84fbb7 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a1fded7c503030e142d45bfbeed84fbb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a1fded7c503030e142d45bfbeed84fbb7">operator&lt;</a> (const <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;rhs) const</td></tr>
<tr class="separator:a1fded7c503030e142d45bfbeed84fbb7 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813f00fad959f24480192a5a44b12cdc inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a813f00fad959f24480192a5a44b12cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a813f00fad959f24480192a5a44b12cdc">Assign</a> (const <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;rhs)</td></tr>
<tr class="memdesc:a813f00fad959f24480192a5a44b12cdc inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the state of one object to another.  <br /></td></tr>
<tr class="separator:a813f00fad959f24480192a5a44b12cdc inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd264e188f728eb9ef1ca60a33000881 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_abd264e188f728eb9ef1ca60a33000881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#abd264e188f728eb9ef1ca60a33000881">operator=</a> (const <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;rhs)</td></tr>
<tr class="memdesc:abd264e188f728eb9ef1ca60a33000881 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that assigns the state of one object to another.  <br /></td></tr>
<tr class="separator:abd264e188f728eb9ef1ca60a33000881 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59314657e3dfd95c0cfcff23e0356e56 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a59314657e3dfd95c0cfcff23e0356e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a59314657e3dfd95c0cfcff23e0356e56">operator=</a> (<a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a59314657e3dfd95c0cfcff23e0356e56 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator that transfers ownership of resources.  <br /></td></tr>
<tr class="separator:a59314657e3dfd95c0cfcff23e0356e56 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae960e617e5485070dac4afcb09aa31c3 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_ae960e617e5485070dac4afcb09aa31c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#ae960e617e5485070dac4afcb09aa31c3">operator==</a> (const <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a50a948c89c10c03e795303f752c828c7">ClassType</a> &amp;rhs) const noexcept</td></tr>
<tr class="separator:ae960e617e5485070dac4afcb09aa31c3 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957f06ccfe0a582b17c0e30edb3caff5 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a957f06ccfe0a582b17c0e30edb3caff5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a957f06ccfe0a582b17c0e30edb3caff5">Empty</a> () const noexcept</td></tr>
<tr class="memdesc:a957f06ccfe0a582b17c0e30edb3caff5 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the delegate is bound to a target function.  <br /></td></tr>
<tr class="separator:a957f06ccfe0a582b17c0e30edb3caff5 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c632ed0a4fd7a40c27a8f05dbefa50 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a63c632ed0a4fd7a40c27a8f05dbefa50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a63c632ed0a4fd7a40c27a8f05dbefa50">Clear</a> () noexcept</td></tr>
<tr class="memdesc:a63c632ed0a4fd7a40c27a8f05dbefa50 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the target function.  <br /></td></tr>
<tr class="separator:a63c632ed0a4fd7a40c27a8f05dbefa50 inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95342174adf1cc93cea485abcc74b49b inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4" id="r_a95342174adf1cc93cea485abcc74b49b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a95342174adf1cc93cea485abcc74b49b">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a95342174adf1cc93cea485abcc74b49b inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion operator to <code>bool</code>.  <br /></td></tr>
<tr class="separator:a95342174adf1cc93cea485abcc74b49b inherit pub_methods_class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_delegate_lib_1_1_delegate_3_01_ret_type_07_args_8_8_8_08_4"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_delegate_lib_1_1_delegate_3_01_ret_type_07_args_8_8_8_08_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_delegate_lib_1_1_delegate_3_01_ret_type_07_args_8_8_8_08_4.html">DelegateLib::Delegate&lt; RetType(Args...)&gt;</a></td></tr>
<tr class="inherit_header pub_methods_class_delegate_lib_1_1_delegate_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_delegate_lib_1_1_delegate_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_delegate_lib_1_1_delegate_base.html">DelegateLib::DelegateBase</a></td></tr>
<tr class="memitem:a0b67663a7b8ab2e491c177235329ad8b inherit pub_methods_class_delegate_lib_1_1_delegate_base" id="r_a0b67663a7b8ab2e491c177235329ad8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_base.html#a0b67663a7b8ab2e491c177235329ad8b">DelegateBase</a> ()=default</td></tr>
<tr class="separator:a0b67663a7b8ab2e491c177235329ad8b inherit pub_methods_class_delegate_lib_1_1_delegate_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e2ba60d330e779b0e993b2f42d9442 inherit pub_methods_class_delegate_lib_1_1_delegate_base" id="r_ab8e2ba60d330e779b0e993b2f42d9442"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_base.html#ab8e2ba60d330e779b0e993b2f42d9442">~DelegateBase</a> () noexcept=default</td></tr>
<tr class="separator:ab8e2ba60d330e779b0e993b2f42d9442 inherit pub_methods_class_delegate_lib_1_1_delegate_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc7f961ee7acc86ce42724e1ef3f5f6 inherit pub_methods_class_delegate_lib_1_1_delegate_base" id="r_a1cc7f961ee7acc86ce42724e1ef3f5f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_base.html#a1cc7f961ee7acc86ce42724e1ef3f5f6">operator==</a> (const <a class="el" href="class_delegate_lib_1_1_delegate_base.html">DelegateBase</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a1cc7f961ee7acc86ce42724e1ef3f5f6 inherit pub_methods_class_delegate_lib_1_1_delegate_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two delegate objects for equality.  <br /></td></tr>
<tr class="separator:a1cc7f961ee7acc86ce42724e1ef3f5f6 inherit pub_methods_class_delegate_lib_1_1_delegate_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170fcb3125188fa4338c90fb2d9cfa73 inherit pub_methods_class_delegate_lib_1_1_delegate_base" id="r_a170fcb3125188fa4338c90fb2d9cfa73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delegate_lib_1_1_delegate_base.html#a170fcb3125188fa4338c90fb2d9cfa73">operator!=</a> (const <a class="el" href="class_delegate_lib_1_1_delegate_base.html">DelegateBase</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a170fcb3125188fa4338c90fb2d9cfa73 inherit pub_methods_class_delegate_lib_1_1_delegate_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two delegate objects for inequality.  <br /></td></tr>
<tr class="separator:a170fcb3125188fa4338c90fb2d9cfa73 inherit pub_methods_class_delegate_lib_1_1_delegate_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_delegate_lib_1_1_i_delegate_invoker"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_delegate_lib_1_1_i_delegate_invoker')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_delegate_lib_1_1_i_delegate_invoker.html">DelegateLib::IDelegateInvoker</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4c3606cc50df42a8086afe833332c797" id="r_a4c3606cc50df42a8086afe833332c797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c3606cc50df42a8086afe833332c797">operator==</a> (std::nullptr_t, const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a4c3606cc50df42a8086afe833332c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9060a79c701f93a271858cb8b787f534" id="r_a9060a79c701f93a271858cb8b787f534"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9060a79c701f93a271858cb8b787f534">operator!=</a> (std::nullptr_t, const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a9060a79c701f93a271858cb8b787f534"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class RetType, class... Args&gt;<br />
class DelegateLib::DelegateFunctionAsync&lt; RetType(Args...)&gt;</div><p><code><a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateFunctionAsync</a>&lt;&gt;</code> class asynchronously invokes a <code>std::function</code> target function. </p>
<p>Caution when binding to a <code>std::function</code> using this class. <code>std::function</code> cannot be compared for equality directly in a meaningful way using <code>operator==</code>. Therefore, the delegate library used</p>
<p>See <code><a class="el" href="class_delegate_lib_1_1_delegate_function.html">DelegateFunction</a>&lt;&gt;</code> base class for important usage limitations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RetType</td><td>The return type of the bound delegate function. </td></tr>
    <tr><td class="paramname">Args</td><td>The argument types of the bound delegate function. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2a303bc469c86c9f50979caae34f2d51" name="a2a303bc469c86c9f50979caae34f2d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a303bc469c86c9f50979caae34f2d51">&#9670;&#160;</a></span>BaseType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::BaseType = <a class="el" href="class_delegate_lib_1_1_delegate_function.html">DelegateFunction</a>&lt;RetType(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e95505c52ba0355839a32e2cacc3480" name="a4e95505c52ba0355839a32e2cacc3480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e95505c52ba0355839a32e2cacc3480">&#9670;&#160;</a></span>ClassType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::ClassType = <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateFunctionAsync</a>&lt;RetType(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4002625654c02248b5b37266bf63ef66" name="a4002625654c02248b5b37266bf63ef66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4002625654c02248b5b37266bf63ef66">&#9670;&#160;</a></span>FunctionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::FunctionType = std::function&lt;RetType(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a46501e1a3392ed1d13e3f3cba8eb2df0" name="a46501e1a3392ed1d13e3f3cba8eb2df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46501e1a3392ed1d13e3f3cba8eb2df0">&#9670;&#160;</a></span>DelegateFunctionAsync() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::DelegateFunctionAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4002625654c02248b5b37266bf63ef66">FunctionType</a></td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_delegate_lib_1_1_delegate_thread.html">DelegateThread</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to create a class instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The target <code>std::function</code> to store. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The execution thread to invoke <code>func</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fb983602c9e3fcecc54907f13b748ce" name="a2fb983602c9e3fcecc54907f13b748ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb983602c9e3fcecc54907f13b748ce">&#9670;&#160;</a></span>DelegateFunctionAsync() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::DelegateFunctionAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor that creates a copy of the given instance. </p>
<p>This constructor initializes a new object as a copy of the provided <code>rhs</code> (right-hand side) object. The <code>rhs</code> object is used to set the state of the new instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adeef2c1b2f887384a21024779b298445" name="adeef2c1b2f887384a21024779b298445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeef2c1b2f887384a21024779b298445">&#9670;&#160;</a></span>DelegateFunctionAsync() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::DelegateFunctionAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor that transfers ownership of resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object to move from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04cd46ce7ba0c9cb5ed9996dd1bddad6" name="a04cd46ce7ba0c9cb5ed9996dd1bddad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cd46ce7ba0c9cb5ed9996dd1bddad6">&#9670;&#160;</a></span>DelegateFunctionAsync() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::DelegateFunctionAsync </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae51e00822c91e01e7041be385ac38c76" name="ae51e00822c91e01e7041be385ac38c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51e00822c91e01e7041be385ac38c76">&#9670;&#160;</a></span>Assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::Assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the state of one object to another. </p>
<p>Copy the state from the <code>rhs</code> (right-hand side) object to the current object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object whose state is to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c0e0c2591b0b02feec73b501325fcb6" name="a5c0e0c2591b0b02feec73b501325fcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0e0c2591b0b02feec73b501325fcb6">&#9670;&#160;</a></span>AsyncInvoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::AsyncInvoke </td>
          <td>(</td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke delegate function asynchronously. Do not wait for return value. Called by the source thread. Always safe to call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The function arguments, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56758d6e931fbff1cfc3ea97151fd6b5" name="a56758d6e931fbff1cfc3ea97151fd6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56758d6e931fbff1cfc3ea97151fd6b5">&#9670;&#160;</a></span>Bind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::Bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4002625654c02248b5b37266bf63ef66">FunctionType</a></td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_delegate_lib_1_1_delegate_thread.html">DelegateThread</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>thread</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a <code>std::function</code> to the delegate. </p>
<p>This method associates a member function (<code>func</code>) with the delegate. Once the function is bound, the delegate can be used to invoke the function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The <code>std::function</code> to bind to the delegate. This function must match the signature of the delegate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The execution thread to invoke <code>func</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12be5d3ae814bea5de0df73d2807bedd" name="a12be5d3ae814bea5de0df73d2807bedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12be5d3ae814bea5de0df73d2807bedd">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> * <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the current object. </p>
<p>Clones the current instance of the class by creating a new object and copying the state of the current object to it. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code>ClassType</code> instance. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The caller is responsible for deleting the clone object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If dynamic memory allocation fails and USE_ASSERTS not defined. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#aff35a45eb0c37f87d4a566c3fabd0850">DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;</a>.</p>

</div>
</div>
<a id="aa26e80dc355d468498afff49fe33762e" name="aa26e80dc355d468498afff49fe33762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26e80dc355d468498afff49fe33762e">&#9670;&#160;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_delegate_lib_1_1_delegate_base.html">DelegateBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two delegate objects for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <code><a class="el" href="class_delegate_lib_1_1_delegate_base.html" title="Non-template base class for all delegates.">DelegateBase</a></code> object to compare with the current object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two delegate objects are equal, <code>false</code> otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#acf4659cce1b8cbaef7989399cfd1bb67">DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;</a>.</p>

</div>
</div>
<a id="a1bd821f85fe65d031a307cf2a8f766d6" name="a1bd821f85fe65d031a307cf2a8f766d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd821f85fe65d031a307cf2a8f766d6">&#9670;&#160;</a></span>GetThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_delegate_lib_1_1_delegate_thread.html">DelegateThread</a> * <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::GetThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the destination thread that the target function is invoked on. </p>

</div>
</div>
<a id="a2b54529a25ce5ee655ce18baa8527f3a" name="a2b54529a25ce5ee655ce18baa8527f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b54529a25ce5ee655ce18baa8527f3a">&#9670;&#160;</a></span>Invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::Invoke </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_delegate_lib_1_1_delegate_msg.html">DelegateMsg</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the delegate function on the destination thread. Called by the destintation thread. </p>
<p>Each source thread call to <code>operator()</code> generate a call to <code><a class="el" href="#a2b54529a25ce5ee655ce18baa8527f3a" title="Invoke the delegate function on the destination thread. Called by the destintation thread.">Invoke()</a></code> on the destination thread. Unlike <code>DelegateAsyncWait</code>, a lock is not required between source and destination <code>delegateMsg</code> access because the source thread is not waiting for the function call to complete. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>The delegate message created and sent within <code><a class="el" href="#a1e6153da03f3d607b1e18deb391c04a4" title="Invoke the bound delegate function asynchronously. Called by the source thread.">operator()(Args... args)</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if target function invoked; <code>false</code> if error. <br  />
 </dd></dl>

<p>Implements <a class="el" href="class_delegate_lib_1_1_i_delegate_invoker.html#aca69f324a6770793cb2c9311fa22273a">DelegateLib::IDelegateInvoker</a>.</p>

</div>
</div>
<a id="af8ed368f2c82a7a70f658d386613a0a1" name="af8ed368f2c82a7a70f658d386613a0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ed368f2c82a7a70f658d386613a0a1">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload operator!= to compare the delegate to nullptr </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if delegate is not null. </dd></dl>

<p>Reimplemented from <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#ae0e0c1a6087b659b9efcb9843f3a41f8">DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;</a>.</p>

</div>
</div>
<a id="a1e6153da03f3d607b1e18deb391c04a4" name="a1e6153da03f3d607b1e18deb391c04a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6153da03f3d607b1e18deb391c04a4">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual RetType <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the bound delegate function asynchronously. Called by the source thread. </p>
<p>Invoke delegate function asynchronously and do not wait for return value. This function is called by the source thread. Dispatches the delegate data into the destination thread message queue. <code><a class="el" href="#a2b54529a25ce5ee655ce18baa8527f3a" title="Invoke the delegate function on the destination thread. Called by the destintation thread.">Invoke()</a></code> must be called by the destination thread to invoke the target function. Always safe to call.</p>
<p>The <code><a class="el" href="class_delegate_lib_1_1_delegate_async_msg.html" title="Stores all function arguments suitable for non-blocking asynchronous calls. Argument data is stored i...">DelegateAsyncMsg</a></code> duplicates and copies the function arguments into heap memory. The source thread is not required to place function arguments into the heap. The delegate library performs all necessary heap and argument coping for the caller. Ensure complex argument data types can be safely copied by creating a copy constructor if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The function arguments, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A default return value. The return value is <em>not</em> returned from the target function. Do not use the return value. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Do not use the return value as its not valid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If dynamic memory allocation fails and USE_ASSERTS not defined. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a782bbda436c2de4749fc8c098dd75945">DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;</a>.</p>

</div>
</div>
<a id="ac677a19f9c6ed6f0d5be06e8b1733d37" name="ac677a19f9c6ed6f0d5be06e8b1733d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac677a19f9c6ed6f0d5be06e8b1733d37">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp; <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator that transfers ownership of resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current object. </dd></dl>

</div>
</div>
<a id="a203dd774ded780851f79cac05c4c719b" name="a203dd774ded780851f79cac05c4c719b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203dd774ded780851f79cac05c4c719b">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp; <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator that assigns the state of one object to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object whose state is to be assigned to the current object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current object. </dd></dl>

</div>
</div>
<a id="aaaeae73b60fd98848556101742538946" name="aaaeae73b60fd98848556101742538946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaeae73b60fd98848556101742538946">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the target function. </p>

<p>Reimplemented from <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#ac1cbcefd3ef63028b61e2c467b551ebf">DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;</a>.</p>

</div>
</div>
<a id="a8f41a0cfc08394b14f178e7b7b667224" name="a8f41a0cfc08394b14f178e7b7b667224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f41a0cfc08394b14f178e7b7b667224">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two delegate objects for equality. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the objects are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aa088fc34ca30b023b0469ab60bf13e92" name="aa088fc34ca30b023b0469ab60bf13e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa088fc34ca30b023b0469ab60bf13e92">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="struct_delegate_lib_1_1_delegate_function_async.html">DelegateLib::DelegateFunctionAsync</a>&lt; RetType(Args...)&gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload operator== to compare the delegate to nullptr </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if delegate is null. </dd></dl>

<p>Reimplemented from <a class="el" href="class_delegate_lib_1_1_delegate_function_3_01_ret_type_07_args_8_8_8_08_4.html#a3c083176824748f380c99f04f4c6c3f3">DelegateLib::DelegateFunction&lt; RetType(Args...)&gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a9060a79c701f93a271858cb8b787f534" name="a9060a79c701f93a271858cb8b787f534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9060a79c701f93a271858cb8b787f534">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload operator!= to compare the delegate to nullptr </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if delegate is not null. </dd></dl>

</div>
</div>
<a id="a4c3606cc50df42a8086afe833332c797" name="a4c3606cc50df42a8086afe833332c797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3606cc50df42a8086afe833332c797">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RetType , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4e95505c52ba0355839a32e2cacc3480">ClassType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload operator== to compare the delegate to nullptr </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if delegate is null. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Projects/cpp-async-delegate/src/Delegate/<a class="el" href="_delegate_async_8h_source.html">DelegateAsync.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_delegate_lib.html">DelegateLib</a></li><li class="navelem"><a class="el" href="class_delegate_lib_1_1_delegate_function_async_3_01_ret_type_07_args_8_8_8_08_4.html">DelegateFunctionAsync&lt; RetType(Args...)&gt;</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
