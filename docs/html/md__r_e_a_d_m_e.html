<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Delegates: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Delegates
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">README</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><img src="https://img.shields.io/github/license/BehaviorTree/BehaviorTree.CPP?color=blue" alt="License MIT" class="inline"/> <a href="https://github.com/endurodave/cpp-async-delegate/actions/workflows/cmake_ubuntu.yml"><img src="https://github.com/endurodave/cpp-async-delegate/actions/workflows/cmake_ubuntu.yml/badge.svg" alt="conan Ubuntu" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/endurodave/cpp-async-delegate/actions/workflows/cmake_clang.yml"><img src="https://github.com/endurodave/cpp-async-delegate/actions/workflows/cmake_clang.yml/badge.svg" alt="conan Ubuntu" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/endurodave/cpp-async-delegate/actions/workflows/cmake_windows.yml"><img src="https://github.com/endurodave/cpp-async-delegate/actions/workflows/cmake_windows.yml/badge.svg" alt="conan Windows" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Asynchronous Delegates in C++</h1>
<p>A C++ delegate library capable of anonymously invoking any callable function either synchronously or asynchronously on a user-specified thread of control. Extensive unit tests ensure compatibility with any C++17 and higher platform.</p>
<p>In C++, a delegate encapsulates a callable entity, such as a function, method, or lambda, so it can be invoked later. A delegate is a type-safe wrapper around a callable function that allows it to be passed around, stored, or invoked at a later time, typically within different contexts or on different threads. Delegates are particularly useful for event-driven programming, callbacks, or when you need to pass functions as arguments.</p>
<p>Asynchronous delegate function calls support both non-blocking and blocking modes with a timeout. The library supports all types of target functions, including free functions, class member functions, static class functions, lambdas, and <code>std::function</code>. It is capable of handling any function signature, regardless of the number of arguments or return value. All argument types are supported, including by value, pointers, pointers to pointers, and references. The delegate library takes care of the intricate details of function invocation across thread boundaries.</p>
<p>It is always safe to call the delegate. In its null state, a call will not perform any action and will return a default-constructed return value. A delegate behaves like a normal pointer type: it can be copied, compared for equality, called, and compared to <code>nullptr</code>. Const correctness is maintained; stored const objects can only be called by const member functions.</p>
<p>A delegate instance can be:</p>
<ul>
<li>Copied freely.</li>
<li>Compared to same type delegates and <code>nullptr</code>.</li>
<li>Reassigned.</li>
<li>Called.</li>
</ul>
<p>Typical use cases are:</p>
<ul>
<li>Asynchronous Method Invocation (AMI)</li>
<li>Publish/Subscribe (Observer) Pattern</li>
<li>Anonymous, Asynchronous Thread-Safe Callbacks</li>
<li>Event-Driven Programming</li>
<li>Thread-Safe Asynchronous API</li>
<li>Design Patterns (Active Object)</li>
</ul>
<p>The delegate library's asynchronous features differ from <code>std::async</code> in that the caller-specified thread of control is used to invoke the target function bound to the delegate, rather than a random thread from the thread pool. The asynchronous variants copy the argument data into the event queue, ensuring safe transport to the destination thread, regardless of the argument type. This approach provides 'fire and forget' functionality, allowing the caller to avoid waiting or worrying about out-of-scope stack variables being accessed by the target thread.</p>
<p>In short, the delegate library offers features that are not natively available in the C++ standard library to ease multi-threaded application development.</p>
<p>Originally published on CodeProject at: <a href="https://www.codeproject.com/Articles/5277036/Asynchronous-Multicast-Delegates-in-Modern-Cpluspl">Asynchronous Multicast Delegates in Modern C++</a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Design Documentation</h1>
<p>See Design Details for implementation design documentation and more examples.</p>
<p>See <a href="https://endurodave.github.io/cpp-async-delegate/html/index.html">Doxygen Documentation</a> for source code documentation.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Quick Start</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Basic Examples</h2>
<p>Simple function definitions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FreeFunc(<span class="keywordtype">int</span> value) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;FreeFuncInt &quot;</span> &lt;&lt; value &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>TestClass {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> MemberFunc(<span class="keywordtype">int</span> value) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;MemberFunc &quot;</span> &lt;&lt; value &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Create delegates and invoke. Function template overloaded <code>MakeDelegate()</code> function is typically used to create a delegate instance.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a delegate bound to a free function then invoke synchronously</span></div>
<div class="line"><span class="keyword">auto</span> delegateFree = MakeDelegate(&amp;FreeFunc);</div>
<div class="line">delegateFree(123);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a delegate bound to a member function then invoke synchronously</span></div>
<div class="line">TestClass testClass;</div>
<div class="line"><span class="keyword">auto</span> delegateMember = MakeDelegate(&amp;testClass, &amp;TestClass::MemberFunc);</div>
<div class="line">delegateMember(123);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a delegate bound to a member function then invoke asynchronously (non-blocking)</span></div>
<div class="line"><span class="keyword">auto</span> delegateMemberAsync = MakeDelegate(&amp;testClass, &amp;TestClass::MemberFunc, workerThread);</div>
<div class="line">delegateMemberAsync(123);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a delegate bound to a member function then invoke asynchronously blocking</span></div>
<div class="line"><span class="keyword">auto</span> delegateMemberAsyncWait = MakeDelegate(&amp;testClass, &amp;TestClass::MemberFunc, workerThread, WAIT_INFINITE);</div>
<div class="line">delegateMemberAsyncWait(123);</div>
</div><!-- fragment --><p>Create a delegate container, insert a delegate instance and invoke asynchronously.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a thread-safe multicast delegate container that accepts Delegate&lt;void(int)&gt; delegates</span></div>
<div class="line">MulticastDelegateSafe&lt;void(<span class="keywordtype">int</span>)&gt; delegateSafe;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add a delegate to the container that will invoke on workerThread1</span></div>
<div class="line">delegateSafe += MakeDelegate(&amp;testClass, &amp;TestClass::MemberFunc, workerThread1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Asynchronously invoke the delegate target member function TestClass::MemberFunc()</span></div>
<div class="line">delegateSafe(123);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove the delegate from the container</span></div>
<div class="line">delegateSafe -= MakeDelegate(&amp;testClass, &amp;TestClass::MemberFunc, workerThread1);</div>
</div><!-- fragment --><p>Invoke a lambda using a delegate.</p>
<div class="fragment"><div class="line">DelegateFunction&lt;int(<span class="keywordtype">int</span>)&gt; delFunc([](<span class="keywordtype">int</span> x) -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> x + 5; });</div>
<div class="line"><span class="keywordtype">int</span> retVal = delFunc(8);</div>
</div><!-- fragment --><p> Asynchronously invoke <code>LambdaFunc1</code> on <code>workerThread1</code> and block waiting for the return value.</p>
<div class="fragment"><div class="line">std::function LambdaFunc1 = [](<span class="keywordtype">int</span> i) -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Called LambdaFunc1 &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> ++i;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Asynchronously invoke lambda on workerThread1 and wait for the return value</span></div>
<div class="line"><span class="keyword">auto</span> lambdaDelegate1 = MakeDelegate(LambdaFunc1, workerThread1, WAIT_INFINITE);</div>
<div class="line"><span class="keywordtype">int</span> lambdaRetVal2 = lambdaDelegate1(123);</div>
</div><!-- fragment --><p>Asynchronously invoke <code>AddFunc</code> on <code>workerThread1</code> using <code>std::async</code> and do other work while waiting for the return value.</p>
<div class="fragment"><div class="line"><span class="comment">// Long running function </span></div>
<div class="line">std::function AddFunc = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    <span class="keywordflow">return</span> a + b;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create async delegate with lambda target function</span></div>
<div class="line"><span class="keyword">auto</span> addDelegate = MakeDelegate(AddFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Using std::async, invokes AddFunc on workerThread1</span></div>
<div class="line">std::future&lt;int&gt; result = std::async(std::launch::async, addDelegate, 5, 3);</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Do work while waiting for AddFunc to complete.&quot;</span> &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for AddFunc return value</span></div>
<div class="line"><span class="keywordtype">int</span> sum = result.get();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;AddFunc return value: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Publish/Subscribe Example</h2>
<p>A simple publish/subscribe example using asynchronous delegates.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Publisher</h3>
<p>Typically a delegate is inserted into a delegate container. <code>AlarmCd</code> is a delegate container.</p>
<p>&lt;figure&gt; <img src="docs/Figure1.jpg" alt="Figure 1" style="width:65%;" class="inline"/> &lt;figcaption&gt;Figure 1: AlarmCb Delegate Container&lt;/figcaption&gt; &lt;/figure&gt;</p>
<ol type="1">
<li><code>MulticastDelegateSafe</code> - the delegate container type.</li>
<li><code>void(int, const string&amp;)</code> - the function signature accepted by the delegate container. Any function matching can be inserted, such as a class member, static or lambda function.</li>
<li><code>AlarmCb</code> - the delegate container name.</li>
</ol>
<p>Invoke delegate container to notify subscribers.</p>
<div class="fragment"><div class="line">MulticastDelegateSafe&lt;void(<span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp;)&gt; AlarmCb;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> NotifyAlarmSubscribers(<span class="keywordtype">int</span> alarmId, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; note)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Invoke delegate to generate callback(s) to subscribers</span></div>
<div class="line">    AlarmCb(alarmId, note);</div>
<div class="line">}</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md6"></a>
Subscriber</h3>
<p>Typically a subscriber registers with a delegate container instance to receive callbacks, either synchronously or asynchronously.</p>
<p>&lt;figure&gt; <img src="docs/Figure2.jpg" alt="Figure 2" style="width:75%;" class="inline"/> &lt;figcaption&gt;Figure 2: Insert into AlarmCb Delegate Container&lt;/figcaption&gt; &lt;/figure&gt;</p>
<ol type="1">
<li><code>AlarmCb</code> - the publisher delegate container instance.</li>
<li><code>+=</code> - add a function target to the container.</li>
<li><code>MakeDelegate</code> - creates a delegate instance.</li>
<li><code>&amp;alarmSub</code> - the subscriber object pointer.</li>
<li><code>&amp;AlarmSub::MemberAlarmCb</code> - the subscriber callback member function.</li>
<li><code>workerThread1</code> - the thread the callback will be invoked on. Adding a thread argument changes the callback type from synchronous to asynchronous.</li>
</ol>
<p>Create a function conforming to the delegate signature. Insert a callable functions into the delegate container.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AlarmSub</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> AlarmSub()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Register to receive callbacks on workerThread1</span></div>
<div class="line">        AlarmCb += MakeDelegate(<span class="keyword">this</span>, &amp;AlarmSub::HandleAlarmCb, workerThread1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> ~AlarmSub()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Unregister from callbacks</span></div>
<div class="line">        AlarmCb -= MakeDelegate(<span class="keyword">this</span>, &amp;AlarmSub::HandleAlarmCb, workerThread1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> HandleAlarmCb(<span class="keywordtype">int</span> alarmId, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; note)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Handle callback here. Called on workerThread1 context.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
All Delegate Types Example</h2>
<p>A delegate container inserting and removing all delegate types.</p>
<div class="fragment"><div class="line">WorkerThread workerThread1(<span class="stringliteral">&quot;WorkerThread1&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> callCnt = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> FreeFunc(<span class="keywordtype">int</span> value) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;FreeFunc &quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ++callCnt &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simple test invoking all target types</span></div>
<div class="line"><span class="keywordtype">void</span> TestAllTargetTypes() {</div>
<div class="line">    <span class="keyword">class </span>Class {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> StaticFunc(<span class="keywordtype">int</span> value) {</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;StaticFunc &quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ++callCnt &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> MemberFunc(<span class="keywordtype">int</span> value) {</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;MemberFunc &quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ++callCnt &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> MemberFuncConst(<span class="keywordtype">int</span> value)<span class="keyword"> const </span>{</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;MemberFuncConst &quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ++callCnt &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> stackVal = 100;</div>
<div class="line">    std::function&lt;void(<span class="keywordtype">int</span>)&gt; LambdaCapture = [stackVal](<span class="keywordtype">int</span> i) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;LambdaCapture &quot;</span> &lt;&lt; i + stackVal &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ++callCnt &lt;&lt; endl;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::function&lt;void(<span class="keywordtype">int</span>)&gt; LambdaNoCapture = [](<span class="keywordtype">int</span> i) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;LambdaNoCapture &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ++callCnt &lt;&lt; endl;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::function&lt;void(<span class="keywordtype">int</span>)&gt; LambdaForcedCapture = +[](<span class="keywordtype">int</span> i) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;LambdaForcedCapture &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ++callCnt &lt;&lt; endl;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Class testClass;</div>
<div class="line">    std::shared_ptr&lt;Class&gt; testClassSp = std::make_shared&lt;Class&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a multicast delegate container that accepts Delegate&lt;void(int)&gt; delegates.</span></div>
<div class="line">    <span class="comment">// Any function with the signature &quot;void Func(int)&quot;.</span></div>
<div class="line">    MulticastDelegateSafe&lt;void(<span class="keywordtype">int</span>)&gt; delegateA;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add all callable function targets to the delegate container</span></div>
<div class="line">    <span class="comment">// Synchronous delegates</span></div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;FreeFunc);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaCapture);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaNoCapture);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaForcedCapture);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;Class::StaticFunc);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFunc);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFuncConst);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFunc);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFuncConst);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Asynchronous delegates</span></div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;FreeFunc, workerThread1);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaCapture, workerThread1);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaNoCapture, workerThread1);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaForcedCapture, workerThread1);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;Class::StaticFunc, workerThread1);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFunc, workerThread1);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFuncConst, workerThread1);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFunc, workerThread1);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFuncConst, workerThread1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Asynchronous blocking delegates</span></div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;FreeFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaCapture, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaNoCapture, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaForcedCapture, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;Class::StaticFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFuncConst, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA += <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFuncConst, workerThread1, WAIT_INFINITE);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Invoke all callable function targets stored within the delegate container</span></div>
<div class="line">    delegateA(123);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for async delegate invocations to complete</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Remove all callable function targets from the delegate container</span></div>
<div class="line">    <span class="comment">// Synchronous delegates</span></div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;FreeFunc);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaCapture);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaNoCapture);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaForcedCapture);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;Class::StaticFunc);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFunc);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFuncConst);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFunc);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFuncConst);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Asynchronous delegates</span></div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;FreeFunc, workerThread1);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaCapture, workerThread1);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaNoCapture, workerThread1);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaForcedCapture, workerThread1);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;Class::StaticFunc, workerThread1);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFunc, workerThread1);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFuncConst, workerThread1);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFunc, workerThread1);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFuncConst, workerThread1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Asynchronous blocking delegates</span></div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;FreeFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaCapture, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaNoCapture, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(LambdaForcedCapture, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;Class::StaticFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(&amp;testClass, &amp;Class::MemberFuncConst, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFunc, workerThread1, WAIT_INFINITE);</div>
<div class="line">    delegateA -= <a class="code hl_function" href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">MakeDelegate</a>(testClassSp, &amp;Class::MemberFuncConst, workerThread1, WAIT_INFINITE);</div>
<div class="line"> </div>
<div class="line">    ASSERT_TRUE(delegateA.Size() == 0);</div>
<div class="line">    ASSERT_TRUE(callCnt == 27);</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_delegate_lib_html_a4815e70cd651512c838e354bf81a0c80"><div class="ttname"><a href="namespace_delegate_lib.html#a4815e70cd651512c838e354bf81a0c80">DelegateLib::MakeDelegate</a></div><div class="ttdeci">auto MakeDelegate(RetType(*func)(Args... args))</div><div class="ttdoc">Creates a delegate that binds to a free function.</div><div class="ttdef"><b>Definition</b> Delegate.h:669</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Asynchronous API Example</h2>
<p><code>SetSystemModeAsyncAPI()</code> is an asynchronous function call that re-invokes on <code>workerThread2</code> if necessary.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> SysDataNoLock::SetSystemModeAsyncAPI(SystemMode::Type systemMode)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Is the caller executing on workerThread2?</span></div>
<div class="line">    <span class="keywordflow">if</span> (workerThread2.GetThreadId() != WorkerThread::GetCurrentThreadId())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Create an asynchronous delegate and re-invoke the function call on workerThread2</span></div>
<div class="line">        MakeDelegate(<span class="keyword">this</span>, &amp;SysDataNoLock::SetSystemModeAsyncAPI, workerThread2).AsyncInvoke(systemMode);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the callback data</span></div>
<div class="line">    SystemModeChanged callbackData;</div>
<div class="line">    callbackData.PreviousSystemMode = m_systemMode;</div>
<div class="line">    callbackData.CurrentSystemMode = systemMode;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Update the system mode</span></div>
<div class="line">    m_systemMode = systemMode;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Callback all registered subscribers</span></div>
<div class="line">    SystemModeChangedDelegate(callbackData);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
Delegate Classes</h1>
<p>Primary delegate library classes.</p>
<div class="fragment"><div class="line"><span class="comment">// Delegates</span></div>
<div class="line">DelegateBase</div>
<div class="line">    Delegate&lt;&gt;</div>
<div class="line">        DelegateFree&lt;&gt;</div>
<div class="line">            DelegateFreeAsync&lt;&gt;</div>
<div class="line">            DelegateFreeAsyncWait&lt;&gt;</div>
<div class="line">        DelegateMember&lt;&gt;</div>
<div class="line">            DelegateMemberAsync&lt;&gt;</div>
<div class="line">            DelegateMemberAsyncWait&lt;&gt;</div>
<div class="line">        DelegateFunction&lt;&gt;</div>
<div class="line">            DelegateFunctionAsync&lt;&gt;</div>
<div class="line">            DelegateFunctionAsyncWait&lt;&gt;</div>
</div><!-- fragment --><p><code>DelegateFree&lt;&gt;</code> binds to a free or static member function. <code>DelegateMember&lt;&gt;</code> binds to a class instance member function. <code>DelegateFunction&lt;&gt;</code> binds to a <code>std::function</code> target. All versions offer synchronous function invocation.</p>
<p><code>DelegateFreeAsync&lt;&gt;</code>, <code>DelegateMemberAsync&lt;&gt;</code> and <code>DelegateFunctionAsync&lt;&gt;</code> operate in the same way as their synchronous counterparts; except these versions offer non-blocking asynchronous function execution on a specified thread of control.</p>
<p><code>DelegateFreeAsyncWait&lt;&gt;</code>, <code>DelegateMemberAsyncWait&lt;&gt;</code> and <code>DelegateFunctionAsyncWait&lt;&gt;</code> provides blocking asynchronous function execution on a target thread with a caller supplied maximum wait timeout. The destination thread will not invoke the target function if the timeout expires.</p>
<p>The three main delegate container classes are:</p>
<div class="fragment"><div class="line"><span class="comment">// Delegate Containers</span></div>
<div class="line">UnicastDelegate&lt;&gt;</div>
<div class="line">MulticastDelegate&lt;&gt;</div>
<div class="line">    MulticastDelegateSafe&lt;&gt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper Classes</span></div>
<div class="line">DelegateMsg</div>
<div class="line">DelegateThread</div>
<div class="line">IDelegateInvoker</div>
</div><!-- fragment --><p><code>UnicastDelegate&lt;&gt;</code> is a delegate container accepting a single delegate.</p>
<p><code>MulticastDelegate&lt;&gt;</code> is a delegate container accepting multiple delegates.</p>
<p><code>MultcastDelegateSafe&lt;&gt;</code> is a thread-safe container accepting multiple delegates. Always use the thread-safe version if multiple threads access the container instance.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Project Build</h1>
<p><a href="https://www.cmake.org">CMake</a> is used to create the build files. CMake is free and open-source software. Windows, Linux and other toolchains are supported. Example CMake console commands executed inside the project root directory:</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Windows Visual Studio</h2>
<p><code>cmake -G "Visual Studio 17 2022" -A Win32 -B build -S .</code></p>
<p><code>cmake -G "Visual Studio 17 2022" -A x64 -B build -S .</code></p>
<p><code>cmake -G "Visual Studio 17 2022" -A x64 -B build -S . -DENABLE_ALLOCATOR=ON</code></p>
<p>After executed, open the Visual Studio project from within the <code>build</code> directory.</p>
<p>&lt;figure&gt; <img src="docs/Figure3.jpg" alt="Figure 3" style="width:100%;" class="inline"/> &lt;figcaption&gt;Figure 3: Visual Studio Build&lt;/figcaption&gt; &lt;/figure&gt;</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Linux Make</h2>
<p><code>cmake -G "Unix Makefiles" -B build -S .</code></p>
<p><code>cmake -G "Unix Makefiles" -B build -S . -DENABLE_ALLOCATOR=ON</code></p>
<p>After executed, build the software from within the <code>build</code> directory using the command <code>make</code>. Run the console app using <code>./DelegateApp</code>.</p>
<p>&lt;figure&gt; <img src="docs/Figure4.jpg" alt="Figure 4" style="width:70%;" class="inline"/> &lt;figcaption&gt;Figure 4: Linux Makefile Build&lt;/figcaption&gt; &lt;/figure&gt;</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Related Repositories</h1>
<h2><a class="anchor" id="autotoc_md14"></a>
Alternative Implementations</h2>
<p>Alternative asynchronous implementations similar in concept to C++ delegate.</p>
<ul>
<li><a href="https://github.com/endurodave/AsyncCallback">Asynchronous Callbacks in C++</a> - A C++ asynchronous callback framework simplifies passing data between threads.</li>
<li><a href="https://github.com/endurodave/C_AsyncCallback">Asynchronous Callbacks in C</a> - A C language asynchronous callback framework simplifies passing data between threads.</li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
Projects Using Delegates</h2>
<p>Repositories utilizing the delegate library within different multithreaded applications.</p>
<ul>
<li><a href="https://github.com/endurodave/AsyncStateMachine">Asynchronous State Machine Design in C++</a> - an asynchronous C++ state machine implemented using an asynchronous delegate library.</li>
<li><a href="https://github.com/endurodave/IntegrationTestFramework">Integration Test Framework using Google Test and Delegates</a> - a multi-threaded C++ software integration test framework using Google Test and Delegate libraries.</li>
<li><a href="https://github.com/endurodave/Async-SQLite">Asynchronous SQLite API using C++ Delegates</a> - an asynchronous SQLite wrapper implemented using an asynchronous delegate library.</li>
</ul>
<h1><a class="anchor" id="autotoc_md16"></a>
Star History</h1>
<p>Find this repository useful? Consider giving it a star!</p>
<p><a href="https://star-history.com/#endurodave/cpp-async-delegate&amp;Date"><img src="https://api.star-history.com/svg?repos=endurodave/cpp-async-delegate&amp;type=Date" alt="Star History Chart" class="inline"/></a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
